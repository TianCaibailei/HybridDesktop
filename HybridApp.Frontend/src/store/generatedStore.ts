// Generated by HybridApp.Core.Generators.TsStoreGenerator
// Do not edit manually
import { create } from 'zustand';

/**
 * 处理复杂嵌套对象和集合数据的示例 ViewModel
 */
export interface ComplexVM {
  /**
   * 设备全局配置信息
   */
  config: DeviceConfig;
  /**
   * 系统状态字典信息
   */
  statusInfo: { [key: string]: string };
  /**
   * 运行日志列表
   */
  logs: any;
}

/**
 * 相机视觉控制模块，处理曝光、增益等实时参数
 */
export interface VisionVM {
  /**
   * 曝光时间（毫秒）
   */
  exposure: number;
  /**
   * 模拟增益倍数
   */
  gain: number;
  /**
   * 是否正在运行图像处理算法
   */
  isRunning: boolean;
}

export interface DeviceConfig {
  internalCamera: CameraParams;
  /**
   * 设备型号名称
   */
  modelName: string;
}

export interface LogEntry {
  /**
   * 日志消息
   */
  message: string;
  /**
   * 日志级别
   */
  level: string;
}

export interface CameraParams {
  /**
   * 水平分辨率
   */
  resolutionX: number;
  /**
   * 垂直分辨率
   */
  resolutionY: number;
  /**
   * 支持的拍摄模式列表
   */
  supportedModes: string[];
}

export interface AppState {
  /**
   * 处理复杂嵌套对象和集合数据的示例 ViewModel
   */
  complexVM: ComplexVM;
  /**
   * 相机视觉控制模块，处理曝光、增益等实时参数
   */
  visionVM: VisionVM;
}

export interface AppActions {
  updateStateFromBackend: (vmName: string, propName: string, value: any) => void;
  setBackendState: (vmName: string, propName: string, value: any) => void;
  initFullState: (fullState: AppState) => void;
}

export const useAppStore = create<AppState & AppActions>((set) => ({
  complexVM: {} as ComplexVM,
  visionVM: {} as VisionVM,
  updateStateFromBackend: (vmName, propName, value) => set((state) => {
    const stateKey = vmName.charAt(0).toLowerCase() + vmName.slice(1);
    const propKey = propName.charAt(0).toLowerCase() + propName.slice(1);
    if (!(stateKey in state)) return state;
    return { ...state, [stateKey]: { ...(state as any)[stateKey], [propKey]: value } };
  }),
  setBackendState: (vmName, propName, value) => {
    const stateKey = vmName.charAt(0).toLowerCase() + vmName.slice(1);
    const propKey = propName.charAt(0).toLowerCase() + propName.slice(1);
    // 1. Update Local Store
    set((state) => ({ ...state, [stateKey]: { ...(state as any)[stateKey], [propKey]: value } }));
    // 2. Push to C# Backend
    if ((window as any).chrome?.webview) {
      (window as any).chrome.webview.postMessage({
        type: 'STATE_SET',
        payload: { vmName, propName, value }
      });
    }
  },
  initFullState: (fullState) => set((state) => {
    const newState: any = { ...state };
    for (const key in fullState) {
        const stateKey = key.charAt(0).toLowerCase() + key.slice(1);
        newState[stateKey] = (fullState as any)[key];
    }
    return newState;
  }),
}));

// ---- Command Invocation ----

const _pendingCommands = new Map<string, { resolve: (v: any) => void; reject: (e: any) => void }>();
let _commandIdCounter = 0;

// Listen for command responses from C# backend
if ((window as any).chrome?.webview) {
  (window as any).chrome.webview.addEventListener('message', (event: any) => {
    const data = event.data;
    if (data?.type === 'COMMAND_RESPONSE' && data.payload?.requestId) {
      const pending = _pendingCommands.get(data.payload.requestId);
      if (pending) {
        _pendingCommands.delete(data.payload.requestId);
        if (data.payload.success) { pending.resolve(data.payload.result); }
        else { pending.reject(new Error(data.payload.error || 'Command failed')); }
      }
    }
  });
}

function invokeCommand(vmName: string, methodName: string, args?: Record<string, any>): void {
  (window as any).chrome?.webview?.postMessage({
    type: 'COMMAND',
    payload: { vmName, methodName, args: args ?? {} }
  });
}

function invokeCommandAsync<T = any>(vmName: string, methodName: string, args?: Record<string, any>): Promise<T> {
  const requestId = `cmd_${++_commandIdCounter}_${Date.now()}`;
  return new Promise<T>((resolve, reject) => {
    _pendingCommands.set(requestId, { resolve, reject });
    (window as any).chrome?.webview?.postMessage({
      type: 'COMMAND',
      payload: { vmName, methodName, args: args ?? {}, requestId }
    });
    // Timeout after 30 seconds
    setTimeout(() => {
      if (_pendingCommands.has(requestId)) {
        _pendingCommands.delete(requestId);
        reject(new Error(`Command ${vmName}.${methodName} timed out`));
      }
    }, 30000);
  });
}

/**
 * 切换运行状态
 * @param reason string
 */
export function VisionVM_ToggleRunning(reason: string): void {
  invokeCommand('VisionVM', 'ToggleRunning', { reason });
}

/**
 * 获取当前视觉模块状态摘要
 * @param prefix string
 * @returns Promise<string>
 */
export function VisionVM_GetStatusSummary(prefix: string): Promise<string> {
  return invokeCommandAsync<string>('VisionVM', 'GetStatusSummary', { prefix });
}

