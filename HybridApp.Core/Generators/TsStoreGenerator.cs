using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using HybridApp.Core.Attributes;
using HybridApp.Core.ViewModels;

namespace HybridApp.Core.Generators
{
    public class TsStoreGenerator
    {
        private readonly HashSet<Type> _discoveredTypes = new HashSet<Type>();
        private readonly List<Type> _typesToGenerate = new List<Type>();

        public void Generate(string outputPath, Assembly? targetAssembly = null)
        {
            var assemblies = targetAssembly != null 
                ? new[] { targetAssembly } 
                : AppDomain.CurrentDomain.GetAssemblies()
                    .Where(a => a.GetName().Name?.StartsWith("HybridApp") == true);

            var viewModels = assemblies
                .SelectMany(a => a.GetTypes())
                .Where(t => t.GetCustomAttribute<SyncViewModelAttribute>() != null)
                .ToList();

            _discoveredTypes.Clear();
            _typesToGenerate.Clear();

            // 1. Discover all types that need interfaces (recursively)
            var queue = new Queue<Type>(viewModels);
            while (queue.Count > 0)
            {
                var type = queue.Dequeue();
                if (_discoveredTypes.Contains(type)) continue;
                _discoveredTypes.Add(type);
                _typesToGenerate.Add(type);

                // Discover nested types from properties
                var props = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                    .Where(p => p.DeclaringType != typeof(SyncViewModelBase) && p.DeclaringType != typeof(object));

                foreach (var prop in props)
                {
                    DiscoverTypes(prop.PropertyType, queue);
                }
            }

            var sb = new StringBuilder();
            sb.AppendLine("// Generated by HybridApp.Core.Generators.TsStoreGenerator");
            sb.AppendLine("// Do not edit manually");
            sb.AppendLine("import { create } from 'zustand';");
            sb.AppendLine();
            
            // 2. Generate actual interface definitions from the discovered list
            foreach (var type in _typesToGenerate)
            {
                sb.Append(BuildInterfaceString(type));
            }

            // 3. Generate AppState Interface
            sb.AppendLine("export interface AppState {");
            foreach (var vm in viewModels)
            {
                var attr = vm.GetCustomAttribute<SyncViewModelAttribute>();
                var vmName = attr?.Name ?? vm.Name;
                var propName = ToCamelCase(vmName);
                if (!string.IsNullOrEmpty(attr?.Description))
                {
                    sb.AppendLine("  /**");
                    sb.AppendLine($"   * {attr.Description}");
                    sb.AppendLine("   */");
                }
                sb.AppendLine($"  {propName}: {vmName};");
            }
            sb.AppendLine("}");
            sb.AppendLine();

            // 4. Generate Actions Interface
            sb.AppendLine("export interface AppActions {");
            sb.AppendLine("  updateStateFromBackend: (vmName: string, propName: string, value: any) => void;");
            sb.AppendLine("  setBackendState: (vmName: string, propName: string, value: any) => void;");
            sb.AppendLine("  initFullState: (fullState: AppState) => void;");
            sb.AppendLine("}");
            sb.AppendLine();

            // 5. Generate Store
            sb.AppendLine("export const useAppStore = create<AppState & AppActions>((set) => ({");
            
            // Initial State
            foreach (var vm in viewModels)
            {
                var attr = vm.GetCustomAttribute<SyncViewModelAttribute>();
                var vmName = attr?.Name ?? vm.Name;
                var propName = ToCamelCase(vmName);
                sb.AppendLine($"  {propName}: {{}} as {vmName},"); 
            }

            // Action: updateStateFromBackend
            sb.AppendLine("  updateStateFromBackend: (vmName, propName, value) => set((state) => {");
            sb.AppendLine("    const stateKey = vmName.charAt(0).toLowerCase() + vmName.slice(1);");
            sb.AppendLine("    const propKey = propName.charAt(0).toLowerCase() + propName.slice(1);");
            sb.AppendLine("    if (!(stateKey in state)) return state;");
            sb.AppendLine("    return { ...state, [stateKey]: { ...(state as any)[stateKey], [propKey]: value } };");
            sb.AppendLine("  }),");

            // Action: setBackendState (Dual-Sync)
            sb.AppendLine("  setBackendState: (vmName, propName, value) => {");
            sb.AppendLine("    const stateKey = vmName.charAt(0).toLowerCase() + vmName.slice(1);");
            sb.AppendLine("    const propKey = propName.charAt(0).toLowerCase() + propName.slice(1);");
            sb.AppendLine("    // 1. Update Local Store");
            sb.AppendLine("    set((state) => ({ ...state, [stateKey]: { ...(state as any)[stateKey], [propKey]: value } }));");
            sb.AppendLine("    // 2. Push to C# Backend");
            sb.AppendLine("    if ((window as any).chrome?.webview) {");
            sb.AppendLine("      (window as any).chrome.webview.postMessage({");
            sb.AppendLine("        type: 'STATE_SET',");
            sb.AppendLine("        payload: { vmName, propName, value }");
            sb.AppendLine("      });");
            sb.AppendLine("    }");
            sb.AppendLine("  },");

            sb.AppendLine("  initFullState: (fullState) => set((state) => {");
            sb.AppendLine("    const newState: any = { ...state };");
            sb.AppendLine("    for (const key in fullState) {");
            sb.AppendLine("        const stateKey = key.charAt(0).toLowerCase() + key.slice(1);");
            sb.AppendLine("        newState[stateKey] = (fullState as any)[key];");
            sb.AppendLine("    }");
            sb.AppendLine("    return newState;");
            sb.AppendLine("  }),");
            sb.AppendLine("}));");
            sb.AppendLine();

            // 6. Generate Command Invocation Utilities
            sb.AppendLine("// ---- Command Invocation ----");
            sb.AppendLine();
            sb.AppendLine("const _pendingCommands = new Map<string, { resolve: (v: any) => void; reject: (e: any) => void }>();");
            sb.AppendLine("let _commandIdCounter = 0;");
            sb.AppendLine();
            sb.AppendLine("// Listen for command responses from C# backend");
            sb.AppendLine("if ((window as any).chrome?.webview) {");
            sb.AppendLine("  (window as any).chrome.webview.addEventListener('message', (event: any) => {");
            sb.AppendLine("    const data = event.data;");
            sb.AppendLine("    if (data?.type === 'COMMAND_RESPONSE' && data.payload?.requestId) {");
            sb.AppendLine("      const pending = _pendingCommands.get(data.payload.requestId);");
            sb.AppendLine("      if (pending) {");
            sb.AppendLine("        _pendingCommands.delete(data.payload.requestId);");
            sb.AppendLine("        if (data.payload.success) { pending.resolve(data.payload.result); }");
            sb.AppendLine("        else { pending.reject(new Error(data.payload.error || 'Command failed')); }");
            sb.AppendLine("      }");
            sb.AppendLine("    }");
            sb.AppendLine("  });");
            sb.AppendLine("}");
            sb.AppendLine();
            sb.AppendLine("function invokeCommand(vmName: string, methodName: string, args?: Record<string, any>): void {");
            sb.AppendLine("  (window as any).chrome?.webview?.postMessage({");
            sb.AppendLine("    type: 'COMMAND',");
            sb.AppendLine("    payload: { vmName, methodName, args: args ?? {} }");
            sb.AppendLine("  });");
            sb.AppendLine("}");
            sb.AppendLine();
            sb.AppendLine("function invokeCommandAsync<T = any>(vmName: string, methodName: string, args?: Record<string, any>): Promise<T> {");
            sb.AppendLine("  const requestId = `cmd_${++_commandIdCounter}_${Date.now()}`;");
            sb.AppendLine("  return new Promise<T>((resolve, reject) => {");
            sb.AppendLine("    _pendingCommands.set(requestId, { resolve, reject });");
            sb.AppendLine("    (window as any).chrome?.webview?.postMessage({");
            sb.AppendLine("      type: 'COMMAND',");
            sb.AppendLine("      payload: { vmName, methodName, args: args ?? {}, requestId }");
            sb.AppendLine("    });");
            sb.AppendLine("    // Timeout after 30 seconds");
            sb.AppendLine("    setTimeout(() => {");
            sb.AppendLine("      if (_pendingCommands.has(requestId)) {");
            sb.AppendLine("        _pendingCommands.delete(requestId);");
            sb.AppendLine("        reject(new Error(`Command ${vmName}.${methodName} timed out`));");
            sb.AppendLine("      }");
            sb.AppendLine("    }, 30000);");
            sb.AppendLine("  });");
            sb.AppendLine("}");
            sb.AppendLine();

            // 7. Generate strongly-typed command wrapper functions per ViewModel
            foreach (var vm in viewModels)
            {
                var vmAttr = vm.GetCustomAttribute<SyncViewModelAttribute>();
                var vmName = vmAttr?.Name ?? vm.Name;

                var commandMethods = vm.GetMethods(BindingFlags.Public | BindingFlags.Instance)
                    .Where(m => m.GetCustomAttribute<SyncCommandAttribute>() != null)
                    .ToList();

                if (commandMethods.Count == 0) continue;

                foreach (var method in commandMethods)
                {
                    var cmdAttr = method.GetCustomAttribute<SyncCommandAttribute>();
                    var returnType = method.ReturnType;
                    bool hasReturn = returnType != typeof(void);
                    string tsReturnType = hasReturn ? MapToTsType(returnType) : "void";

                    // JSDoc comment with description and parameter info
                    sb.AppendLine("/**");
                    if (!string.IsNullOrEmpty(cmdAttr?.Description))
                        sb.AppendLine($" * {cmdAttr.Description}");
                    
                    foreach (var p in method.GetParameters())
                    {
                        sb.AppendLine($" * @param {p.Name} {MapToTsType(p.ParameterType)}");
                    }

                    if (hasReturn)
                        sb.AppendLine($" * @returns Promise<{tsReturnType}>");

                    sb.AppendLine(" */");

                    // Build function signature
                    var paramStrings = method.GetParameters()
                        .Select(p => $"{p.Name}: {MapToTsType(p.ParameterType)}")
                        .ToList();
                    string paramsList = string.Join(", ", paramStrings);

                    // Build args object
                    var argNames = method.GetParameters().Select(p => p.Name).ToList();
                    string argsObj = argNames.Count > 0
                        ? "{ " + string.Join(", ", argNames) + " }"
                        : "{}";

                    if (hasReturn)
                    {
                        sb.AppendLine($"export function {vmName}_{method.Name}({paramsList}): Promise<{tsReturnType}> {{");
                        sb.AppendLine($"  return invokeCommandAsync<{tsReturnType}>('{vmName}', '{method.Name}', {argsObj});");
                    }
                    else
                    {
                        sb.AppendLine($"export function {vmName}_{method.Name}({paramsList}): void {{");
                        sb.AppendLine($"  invokeCommand('{vmName}', '{method.Name}', {argsObj});");
                    }
                    sb.AppendLine("}");
                    sb.AppendLine();
                }
            }

            var dir = Path.GetDirectoryName(outputPath);
            if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir)) Directory.CreateDirectory(dir);
            File.WriteAllText(outputPath, sb.ToString());
        }

        private void DiscoverTypes(Type type, Queue<Type> queue)
        {
            var underlyingType = Nullable.GetUnderlyingType(type) ?? type;
            
            if (underlyingType.IsArray)
            {
                var elementType = underlyingType.GetElementType();
                if (elementType != null) DiscoverTypes(elementType, queue);
            }
            else if (underlyingType.IsGenericType)
            {
                foreach (var arg in underlyingType.GetGenericArguments())
                {
                    DiscoverTypes(arg, queue);
                }
            }
            else if (underlyingType.IsClass && underlyingType != typeof(string))
            {
                if (!_discoveredTypes.Contains(underlyingType))
                {
                    queue.Enqueue(underlyingType);
                }
            }
        }

        private string BuildInterfaceString(Type type)
        {
            var sb = new StringBuilder();
            var vmAttr = type.GetCustomAttribute<SyncViewModelAttribute>();
            var interfaceName = vmAttr?.Name ?? type.Name;

            if (!string.IsNullOrEmpty(vmAttr?.Description))
            {
                sb.AppendLine("/**");
                sb.AppendLine($" * {vmAttr.Description}");
                sb.AppendLine(" */");
            }

            sb.AppendLine($"export interface {interfaceName} {{");
            
            var properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                .Where(p => p.DeclaringType != typeof(SyncViewModelBase) && p.DeclaringType != typeof(object));

            foreach (var prop in properties)
            {
                var syncAttr = prop.GetCustomAttribute<SyncPropertyAttribute>();
                var tsType = MapToTsType(prop.PropertyType);
                var propName = ToCamelCase(prop.Name);
                
                if (!string.IsNullOrEmpty(syncAttr?.Description))
                {
                    sb.AppendLine("  /**");
                    sb.AppendLine($"   * {syncAttr.Description}");
                    sb.AppendLine("   */");
                }
                sb.AppendLine($"  {propName}: {tsType};");
            }
            
            sb.AppendLine("}");
            sb.AppendLine();
            return sb.ToString();
        }

        private string MapToTsType(Type type)
        {
            var underlyingType = Nullable.GetUnderlyingType(type);
            var isNullable = underlyingType != null;
            var targetType = underlyingType ?? type;

            string tsType = "any";

            if (IsNumericType(targetType))
            {
                tsType = "number";
            }
            else if (targetType == typeof(string) || targetType == typeof(Guid))
            {
                tsType = "string";
            }
            else if (targetType == typeof(bool))
            {
                tsType = "boolean";
            }
            else if (targetType == typeof(DateTime) || targetType == typeof(DateTimeOffset))
            {
                tsType = "string";
            }
            else if (targetType.IsArray)
            {
                var elementType = targetType.GetElementType();
                tsType = elementType != null ? $"{MapToTsType(elementType)}[]" : "any[]";
            }
            else if (targetType.IsGenericType)
            {
                var genericDef = targetType.GetGenericTypeDefinition();
                if (genericDef == typeof(List<>) || genericDef == typeof(IEnumerable<>) || genericDef == typeof(IList<>) || genericDef == typeof(IReadOnlyList<>))
                {
                    var argType = targetType.GetGenericArguments()[0];
                    tsType = $"{MapToTsType(argType)}[]";
                }
                else if (genericDef == typeof(Dictionary<,>) || genericDef == typeof(IDictionary<,>) || genericDef == typeof(IReadOnlyDictionary<,>))
                {
                    var keyType = targetType.GetGenericArguments()[0];
                    var valueType = targetType.GetGenericArguments()[1];
                    var tsKeyType = MapToTsType(keyType);
                    var tsValueType = MapToTsType(valueType);
                    
                    if (tsKeyType == "string" || tsKeyType == "number")
                    {
                        tsType = $"{{ [key: {tsKeyType}]: {tsValueType} }}";
                    }
                    else
                    {
                        tsType = $"Record<string, {tsValueType}>";
                    }
                }
            }
            else if (targetType.IsClass && targetType != typeof(string))
            {
                tsType = targetType.Name;
            }

            return isNullable ? $"{tsType} | null" : tsType;
        }

        private bool IsNumericType(Type type)
        {
            return type == typeof(int) || type == typeof(long) || type == typeof(double) || 
                   type == typeof(float) || type == typeof(decimal) || type == typeof(byte) || 
                   type == typeof(short) || type == typeof(uint) || type == typeof(ulong) || 
                   type == typeof(ushort) || type == typeof(sbyte);
        }

        private string ToCamelCase(string str)
        {
            if (string.IsNullOrEmpty(str)) return str;
            if (str.Length == 1) return str.ToLowerInvariant();
            return char.ToLowerInvariant(str[0]) + str.Substring(1);
        }
    }
}