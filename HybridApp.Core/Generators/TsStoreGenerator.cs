using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using HybridApp.Core.Attributes;
using HybridApp.Core.ViewModels;

namespace HybridApp.Core.Generators
{
    public class TsStoreGenerator
    {
        private readonly HashSet<Type> _discoveredTypes = new HashSet<Type>();
        private readonly List<Type> _typesToGenerate = new List<Type>();

        public void Generate(string outputPath, Assembly? targetAssembly = null)
        {
            var assemblies = targetAssembly != null 
                ? new[] { targetAssembly } 
                : AppDomain.CurrentDomain.GetAssemblies()
                    .Where(a => a.GetName().Name?.StartsWith("HybridApp") == true);

            var viewModels = assemblies
                .SelectMany(a => a.GetTypes())
                .Where(t => t.GetCustomAttribute<SyncViewModelAttribute>() != null)
                .ToList();

            _discoveredTypes.Clear();
            _typesToGenerate.Clear();

            // 1. Discover all types that need interfaces (recursively)
            var queue = new Queue<Type>(viewModels);
            while (queue.Count > 0)
            {
                var type = queue.Dequeue();
                if (_discoveredTypes.Contains(type)) continue;
                _discoveredTypes.Add(type);
                _typesToGenerate.Add(type);

                // Discover nested types from properties
                var props = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                    .Where(p => p.DeclaringType != typeof(SyncViewModelBase) && p.DeclaringType != typeof(object));

                foreach (var prop in props)
                {
                    DiscoverTypes(prop.PropertyType, queue);
                }
            }

            var sb = new StringBuilder();
            sb.AppendLine("// Generated by HybridApp.Core.Generators.TsStoreGenerator");
            sb.AppendLine("// Do not edit manually");
            sb.AppendLine("import { create } from 'zustand';");
            sb.AppendLine();
            
            // 2. Generate actual interface definitions from the discovered list
            foreach (var type in _typesToGenerate)
            {
                sb.Append(BuildInterfaceString(type));
            }

            // 3. Generate AppState Interface
            sb.AppendLine("export interface AppState {");
            foreach (var vm in viewModels)
            {
                var attr = vm.GetCustomAttribute<SyncViewModelAttribute>();
                var vmName = attr?.Name ?? vm.Name;
                var propName = ToCamelCase(vmName);
                if (!string.IsNullOrEmpty(attr?.Description))
                {
                    sb.AppendLine("  /**");
                    sb.AppendLine($"   * {attr.Description}");
                    sb.AppendLine("   */");
                }
                sb.AppendLine($"  {propName}: {vmName};");
            }
            sb.AppendLine("}");
            sb.AppendLine();

            // 4. Generate Actions Interface
            sb.AppendLine("export interface AppActions {");
            sb.AppendLine("  updateStateFromBackend: (vmName: string, propName: string, value: any) => void;");
            sb.AppendLine("  setBackendState: (vmName: string, propName: string, value: any) => void;");
            sb.AppendLine("  initFullState: (fullState: AppState) => void;");
            sb.AppendLine("}");
            sb.AppendLine();

            // 5. Generate Store
            sb.AppendLine("export const useAppStore = create<AppState & AppActions>((set, get) => ({");
            
            // Initial State
            foreach (var vm in viewModels)
            {
                var attr = vm.GetCustomAttribute<SyncViewModelAttribute>();
                var vmName = attr?.Name ?? vm.Name;
                var propName = ToCamelCase(vmName);
                sb.AppendLine($"  {propName}: {{}} as {vmName},"); 
            }

            // Action: updateStateFromBackend
            sb.AppendLine("  updateStateFromBackend: (vmName, propName, value) => set((state) => {");
            sb.AppendLine("    const stateKey = vmName.charAt(0).toLowerCase() + vmName.slice(1);");
            sb.AppendLine("    const propKey = propName.charAt(0).toLowerCase() + propName.slice(1);");
            sb.AppendLine("    if (!(stateKey in state)) return state;");
            sb.AppendLine("    return { ...state, [stateKey]: { ...(state as any)[stateKey], [propKey]: value } };");
            sb.AppendLine("  }),");

            // Action: setBackendState (Dual-Sync)
            sb.AppendLine("  setBackendState: (vmName, propName, value) => {");
            sb.AppendLine("    const stateKey = vmName.charAt(0).toLowerCase() + vmName.slice(1);");
            sb.AppendLine("    const propKey = propName.charAt(0).toLowerCase() + propName.slice(1);");
            sb.AppendLine("    // 1. Update Local Store");
            sb.AppendLine("    set((state) => ({ ...state, [stateKey]: { ...(state as any)[stateKey], [propKey]: value } }));");
            sb.AppendLine("    // 2. Push to C# Backend");
            sb.AppendLine("    if ((window as any).chrome?.webview) {");
            sb.AppendLine("      (window as any).chrome.webview.postMessage({");
            sb.AppendLine("        type: 'STATE_SET',");
            sb.AppendLine("        payload: { vmName, propName, value }");
            sb.AppendLine("      });");
            sb.AppendLine("    }");
            sb.AppendLine("  },");

            sb.AppendLine("  initFullState: (fullState) => set((state) => {");
            sb.AppendLine("    const newState: any = { ...state };");
            sb.AppendLine("    for (const key in fullState) {");
            sb.AppendLine("        const stateKey = key.charAt(0).toLowerCase() + key.slice(1);");
            sb.AppendLine("        newState[stateKey] = (fullState as any)[key];");
            sb.AppendLine("    }");
            sb.AppendLine("    return newState;");
            sb.AppendLine("  }),");
            sb.AppendLine("}));");

            var dir = Path.GetDirectoryName(outputPath);
            if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir)) Directory.CreateDirectory(dir);
            File.WriteAllText(outputPath, sb.ToString());
        }

        private void DiscoverTypes(Type type, Queue<Type> queue)
        {
            var underlyingType = Nullable.GetUnderlyingType(type) ?? type;
            
            if (underlyingType.IsArray)
            {
                var elementType = underlyingType.GetElementType();
                if (elementType != null) DiscoverTypes(elementType, queue);
            }
            else if (underlyingType.IsGenericType)
            {
                foreach (var arg in underlyingType.GetGenericArguments())
                {
                    DiscoverTypes(arg, queue);
                }
            }
            else if (underlyingType.IsClass && underlyingType != typeof(string))
            {
                if (!_discoveredTypes.Contains(underlyingType))
                {
                    queue.Enqueue(underlyingType);
                }
            }
        }

        private string BuildInterfaceString(Type type)
        {
            var sb = new StringBuilder();
            var vmAttr = type.GetCustomAttribute<SyncViewModelAttribute>();
            var interfaceName = vmAttr?.Name ?? type.Name;

            if (!string.IsNullOrEmpty(vmAttr?.Description))
            {
                sb.AppendLine("/**");
                sb.AppendLine($" * {vmAttr.Description}");
                sb.AppendLine(" */");
            }

            sb.AppendLine($"export interface {interfaceName} {{");
            
            var properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                .Where(p => p.DeclaringType != typeof(SyncViewModelBase) && p.DeclaringType != typeof(object));

            foreach (var prop in properties)
            {
                var syncAttr = prop.GetCustomAttribute<SyncPropertyAttribute>();
                var tsType = MapToTsType(prop.PropertyType);
                var propName = ToCamelCase(prop.Name);
                
                if (!string.IsNullOrEmpty(syncAttr?.Description))
                {
                    sb.AppendLine("  /**");
                    sb.AppendLine($"   * {syncAttr.Description}");
                    sb.AppendLine("   */");
                }
                sb.AppendLine($"  {propName}: {tsType};");
            }
            
            sb.AppendLine("}");
            sb.AppendLine();
            return sb.ToString();
        }

        private string MapToTsType(Type type)
        {
            var underlyingType = Nullable.GetUnderlyingType(type);
            var isNullable = underlyingType != null;
            var targetType = underlyingType ?? type;

            string tsType = "any";

            if (IsNumericType(targetType))
            {
                tsType = "number";
            }
            else if (targetType == typeof(string) || targetType == typeof(Guid))
            {
                tsType = "string";
            }
            else if (targetType == typeof(bool))
            {
                tsType = "boolean";
            }
            else if (targetType == typeof(DateTime) || targetType == typeof(DateTimeOffset))
            {
                tsType = "string";
            }
            else if (targetType.IsArray)
            {
                var elementType = targetType.GetElementType();
                tsType = elementType != null ? $"{MapToTsType(elementType)}[]" : "any[]";
            }
            else if (targetType.IsGenericType)
            {
                var genericDef = targetType.GetGenericTypeDefinition();
                if (genericDef == typeof(List<>) || genericDef == typeof(IEnumerable<>) || genericDef == typeof(IList<>) || genericDef == typeof(IReadOnlyList<>))
                {
                    var argType = targetType.GetGenericArguments()[0];
                    tsType = $"{MapToTsType(argType)}[]";
                }
                else if (genericDef == typeof(Dictionary<,>) || genericDef == typeof(IDictionary<,>) || genericDef == typeof(IReadOnlyDictionary<,>))
                {
                    var keyType = targetType.GetGenericArguments()[0];
                    var valueType = targetType.GetGenericArguments()[1];
                    var tsKeyType = MapToTsType(keyType);
                    var tsValueType = MapToTsType(valueType);
                    
                    if (tsKeyType == "string" || tsKeyType == "number")
                    {
                        tsType = $"{{ [key: {tsKeyType}]: {tsValueType} }}";
                    }
                    else
                    {
                        tsType = $"Record<string, {tsValueType}>";
                    }
                }
            }
            else if (targetType.IsClass && targetType != typeof(string))
            {
                tsType = targetType.Name;
            }

            return isNullable ? $"{tsType} | null" : tsType;
        }

        private bool IsNumericType(Type type)
        {
            return type == typeof(int) || type == typeof(long) || type == typeof(double) || 
                   type == typeof(float) || type == typeof(decimal) || type == typeof(byte) || 
                   type == typeof(short) || type == typeof(uint) || type == typeof(ulong) || 
                   type == typeof(ushort) || type == typeof(sbyte);
        }

        private string ToCamelCase(string str)
        {
            if (string.IsNullOrEmpty(str)) return str;
            if (str.Length == 1) return str.ToLowerInvariant();
            return char.ToLowerInvariant(str[0]) + str.Substring(1);
        }
    }
}