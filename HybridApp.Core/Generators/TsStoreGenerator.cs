using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using HybridApp.Core.Attributes;
using HybridApp.Core.ViewModels;

namespace HybridApp.Core.Generators
{
    public class TsStoreGenerator
    {
        public void Generate(string outputPath, Assembly? targetAssembly = null)
        {
            var assemblies = targetAssembly != null 
                ? new[] { targetAssembly } 
                : AppDomain.CurrentDomain.GetAssemblies();

            // Find all types with [SyncViewModel] attribute
            var viewModels = assemblies
                .SelectMany(a => a.GetTypes())
                .Where(t => t.GetCustomAttribute<SyncViewModelAttribute>() != null)
                .ToList();

            var sb = new StringBuilder();
            sb.AppendLine("// Generated by HybridApp.Core.Generators.TsStoreGenerator");
            sb.AppendLine("// Do not edit manually");
            sb.AppendLine("import { create } from 'zustand';");
            sb.AppendLine();

            // 1. Generate Interfaces for each ViewModel
            foreach (var vm in viewModels)
            {
                var attr = vm.GetCustomAttribute<SyncViewModelAttribute>();
                var vmName = attr?.Name ?? vm.Name;
                
                sb.AppendLine($"export interface {vmName} {{");
                
                // Get public instance properties, including inherited ones, but exclude SyncViewModelBase and Object props
                var properties = vm.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                    .Where(p => p.DeclaringType != typeof(SyncViewModelBase) && p.DeclaringType != typeof(object));

                foreach (var prop in properties)
                {
                    var tsType = MapToTsType(prop.PropertyType);
                    var propName = ToCamelCase(prop.Name);
                    sb.AppendLine($"  {propName}: {tsType};");
                }
                
                sb.AppendLine("}");
                sb.AppendLine();
            }

            // 2. Generate AppState Interface
            sb.AppendLine("export interface AppState {");
            foreach (var vm in viewModels)
            {
                var attr = vm.GetCustomAttribute<SyncViewModelAttribute>();
                var vmName = attr?.Name ?? vm.Name;
                var propName = ToCamelCase(vmName);
                sb.AppendLine($"  {propName}: {vmName};");
            }
            sb.AppendLine("}");
            sb.AppendLine();

            // 3. Generate Actions Interface
            sb.AppendLine("export interface AppActions {");
            sb.AppendLine("  updateStateFromBackend: (vmName: string, propName: string, value: any) => void;");
            sb.AppendLine("  setBackendState: (newState: Partial<AppState>) => void;");
            sb.AppendLine("  initFullState: (fullState: AppState) => void;");
            sb.AppendLine("}");
            sb.AppendLine();

            // 4. Generate Store
            sb.AppendLine("export const useAppStore = create<AppState & AppActions>((set) => ({");
            
            // Initial State
            foreach (var vm in viewModels)
            {
                var attr = vm.GetCustomAttribute<SyncViewModelAttribute>();
                var vmName = attr?.Name ?? vm.Name;
                var propName = ToCamelCase(vmName);
                sb.AppendLine($"  {propName}: {{}} as {vmName},"); 
            }

            // Actions
            sb.AppendLine("  updateStateFromBackend: (vmName, propName, value) => set((state) => {");
            sb.AppendLine("    // Convert PascalCase vmName to camelCase state key");
            sb.AppendLine("    const stateKey = vmName.charAt(0).toLowerCase() + vmName.slice(1);");
            sb.AppendLine("    // Check if the state key exists to avoid runtime errors");
            sb.AppendLine("    if (!(stateKey in state)) return state;");
            sb.AppendLine("    ");
            sb.AppendLine("    return {");
            sb.AppendLine("      ...state,");
            sb.AppendLine("      [stateKey]: {");
            sb.AppendLine("        ...(state as any)[stateKey],");
            sb.AppendLine("        [propName]: value");
            sb.AppendLine("      }");
            sb.AppendLine("    };");
            sb.AppendLine("  }),");

            // setBackendState implementation
            sb.AppendLine("  setBackendState: (newState) => set((state) => ({ ...state, ...newState })),");
            
            // initFullState implementation
            sb.AppendLine("  initFullState: (fullState) => set(fullState),");

            sb.AppendLine("}));");

            // Ensure directory exists
            var dir = Path.GetDirectoryName(outputPath);
            if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir))
            {
                Directory.CreateDirectory(dir);
            }

            File.WriteAllText(outputPath, sb.ToString());
        }

        private string MapToTsType(Type type)
        {
            var underlyingType = Nullable.GetUnderlyingType(type);
            var isNullable = underlyingType != null;
            var targetType = underlyingType ?? type;

            string tsType = "any";

            if (IsNumericType(targetType))
            {
                tsType = "number";
            }
            else if (targetType == typeof(string) || targetType == typeof(Guid))
            {
                tsType = "string";
            }
            else if (targetType == typeof(bool))
            {
                tsType = "boolean";
            }
            else if (targetType == typeof(DateTime) || targetType == typeof(DateTimeOffset))
            {
                tsType = "string";
            }
            else if (targetType.IsArray)
            {
                var elementType = targetType.GetElementType();
                tsType = elementType != null ? $"{MapToTsType(elementType)}[]" : "any[]";
            }
            else if (targetType.IsGenericType)
            {
                var genericDef = targetType.GetGenericTypeDefinition();
                if (genericDef == typeof(List<>) || genericDef == typeof(IEnumerable<>) || genericDef == typeof(IList<>) || genericDef == typeof(IReadOnlyList<>))
                {
                    var argType = targetType.GetGenericArguments()[0];
                    tsType = $"{MapToTsType(argType)}[]";
                }
                else if (genericDef == typeof(Dictionary<,>) || genericDef == typeof(IDictionary<,>) || genericDef == typeof(IReadOnlyDictionary<,>))
                {
                    var keyType = targetType.GetGenericArguments()[0];
                    var valueType = targetType.GetGenericArguments()[1];
                    var tsKeyType = MapToTsType(keyType);
                    var tsValueType = MapToTsType(valueType);
                    
                    // TS only supports string/number/symbol as key.
                    // If key is number, TS allows it in index signature.
                    if (tsKeyType == "string" || tsKeyType == "number")
                    {
                        tsType = $"{{ [key: {tsKeyType}]: {tsValueType} }}";
                    }
                    else
                    {
                        tsType = $"Record<string, {tsValueType}>";
                    }
                }
            }

            return isNullable ? $"{tsType} | null" : tsType;
        }

        private bool IsNumericType(Type type)
        {
            return type == typeof(int) || type == typeof(long) || type == typeof(double) || 
                   type == typeof(float) || type == typeof(decimal) || type == typeof(byte) || 
                   type == typeof(short) || type == typeof(uint) || type == typeof(ulong) || 
                   type == typeof(ushort) || type == typeof(sbyte);
        }

        private string ToCamelCase(string str)
        {
            if (string.IsNullOrEmpty(str)) return str;
            if (str.Length == 1) return str.ToLowerInvariant();
            return char.ToLowerInvariant(str[0]) + str.Substring(1);
        }
    }
}